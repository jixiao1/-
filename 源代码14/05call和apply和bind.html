<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>我是h1标签</h1>
    <script>
        /* 
            + 函数的调用方式决定函数内部this的指向
                ==>有三个方法可以改变函数内部的this指向,而不管他以前的指向
                ==>call和applay和bind
                ==>强行改变this的指向的方法
            + call
                ==>call在函数调用后面使用,可以忽略函数本身的this指向
                ==>语法:函数名.call(要改变的this的指向,要给函数传递的参数1,要给函数传递的参数2,...)
                ==>fn()直接全局调用的时候,里面的this是window
                ==>fn.call(h1,11,22,33),函数内部的this指向h1
                ==>call会立即执行函数
                ==>第一个参数:要改变的this的指向
                ==>第二个参数开始:一次是传递给函数的实参
            + apply
                ==>apply在函数调用后面使用,可以忽略函数本身的this指向
                ==>语法:函数名.apply(要改变的this的指向,[要给函数传递的参数1,要给函数传递的参数2,...])
                ==>fn()直接全局调用的时候,里面的this是window
                ==>fn.apply(h1,11,22,33),函数内部的this指向h1
                ==>apply会立即执行函数
                ==>第一个参数:要改变的this的指向
                ==>第二个参数是一个数组,数组里面每一项一次是函数的实参
            + bind
                ==>bind在函数调用后面使用,可以忽略函数本身的this指向
                ==>语法:函数名.bind(要改变的this指向)
                ==>和call/apply有些不一样,不会立即执行函数,而是返回一个已经改变了this指向的函数
                ==>bind调用的时候,不会执行fn这个函数,而是返回一个新的函数
                ==>这个函数就是一个改变了this指向的函数
                ==>fn(1111,2222,3333),里面的this还是window
                ==>newFn(11111,22222,33333);函数里面的this就是h1
        */

        var h1 = document.querySelector('h1');

        console.log('============这是全局调用函数fn============')
        function fn(a,b,c){
            console.log(this);
            console.log(a)
            console.log(b)
            console.log(c)
        }

        fn(1,2,3);//window,1,2,3


        console.log('============这是通过call调用函数fn============')
        //call
        fn.call(h1,11,22,33);

        console.log('============这是通过apply调用函数fn============')
        //apply
        fn.apply(h1,[111,222,333])

        console.log('============这是通过bind改变函数fn的this指向============')
        //bind
        var newFn = fn.bind(h1);//此处是是改变this指向,不执行函数,返回的改变了this指向的函数
        fn(1111,2222,3333);//原来函数不便
        newFn(11111,22222,33333);//函数里面的this就是h1


        console.log("============题目:求数组的最大值================")
        //题目:求数组的最大值
        var arr = [21,3434,1,32,4545,2343,2,32,3,2,323];
        console.log(Math.max.apply(null,arr))
    </script>
</body>
</html>