<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /* 
            数组的排序:
                ==>排序:就是把一个乱序的数组,通过我们的处理,让他变成一个有序的数组
                ==>今天我们讲解两种方式来排序一个数组:冒泡排序和选择排序
                ==>冒泡排序(从小到大为例)
                    ==>先遍历数组,让挨着的两个元素进行比较,如果前一个比后一个大,那么就把两个换个位置
                    ==>数组遍历过一遍以后,那么最后一个数字就是最大的那个了
                    ==>再进行第二次遍历,还是按照之前的规则,第二大的数字就会跑到倒数第二的位置
                    ==>以此类推,最好就会按照顺序把数组排好了
                ==>选择排序
        */

        //1 冒泡排序的原理演示
        // var arr = [453,3,45,2,42,3];
        //这是第一遍的遍历,arr[5]是最大的了  j = 0
        
        //i=0 [3,453,45,2,42,3]
        //i=1 [3,45,453,2,42,3]
        //i=2 [3,45,2,453,42,3]
        //i=3 [3,45,2,42,453,3]
        //i=4 [3,45,2,42,3,453]
        //i=5 [3,45,2,42,3,453]  

        //[3,45,2,42,3,453]
        //这是第二遍的遍历   j = 1
        //i=0 [3,45,2,42,3,453]
        //i=1 [3,2,45,42,3,453]
        //i=2 [3,2,42,45,3,453]
        //i=3 [3,2,42,3,45,453]
        //i=4 [3,2,42,3,45,453] 
        //i=5 [3,2,42,3,45,453] //这次是多余的


        //先不急着排序,先要会换位置
        var tempArr = [2,3]        
        //需要一个新的临时变量记录其中一个的值
        var temp = tempArr[0];
        tempArr[0] = tempArr[1];
        tempArr[1] = temp;
        console.log(tempArr)

        //2 冒泡排序
        //先准备一个乱序的数组
        var arr = [453,3,45,2,42,3];
        //接下来让代码进行数组排序
        //第一次遍历数组,把最大的放到最后面去
        // for(var i=0;i<arr.length;i++){
        //     //如果前一个比后一个大,那么就把两个换个位置
        //     if(arr[i]>arr[i+1]){
        //         var temp = arr[i];
        //         arr[i] = arr[i+1];
        //         arr[i+1] = temp;
        //     }
        // }
        //第一次结束以后,数组中的最后一个,就会是最大的那个数字
        //然后我们把上面的代码执行多次,数组有多少项就执行的多少次

        //按照数组的长度来遍历多少次
        // for(var j=0;j<arr.length;j++){
        //     for(var i=0;i<arr.length;i++){
        //         //如果前一个比后一个大,那么就把两个换个位置
        //         if(arr[i]>arr[i+1]){
        //             var temp = arr[i];
        //             arr[i] = arr[i+1];
        //             arr[i+1] = temp;
        //         }
        //     }
        // }
        // console.log(arr);
        /* 
        给一些优化:
            ==>想一个问题,假设数组程度为6,第5次排外以后,剩下的那一次不用排了
                ==>外层循环就是j=0到j<arr.length-1
            ==>再想一个问题,第一次比的时候,已经把最大的比出来了,下次就不用比最后一个了
                ==>内存循环,每次遍历到的最大的都比上次少一次,就是i=0到i<arr.length-j
            ==>每次比较的时候,最后一个元素后面没有元素,可以不比较,所以次数还可以-1
            ==>优化结果就是:
        */
        for(var j=0;j<arr.length-1;j++){
            for(var i=0;i<arr.length-j-1;i++){
                //如果前一个比后一个大,那么就把两个换个位置
                if(arr[i]>arr[i+1]){
                    var temp = arr[i];
                    arr[i] = arr[i+1];
                    arr[i+1] = temp;
                }
            }
        }
        console.log(arr);
    </script>
</body>
</html>